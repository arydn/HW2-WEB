# پروژه‌ی ترسیم اشکال با React و TypeScript

این پروژه شامل پیاده‌سازی یک برنامه‌ی تعاملی برای ترسیم اشکال هندسی در مرورگر است. تکنولوژی‌های اصلی مورد استفاده در این پروژه شامل React، TypeScript، CSS Modules و HTML5 Drag & Drop API می‌باشند. در ادامه، ساختار پوشه‌ی `src/` به همراه شرح عملکرد هر فایل و پیاده‌سازی دقیق ویژگی‌ها آورده شده است.

---

## ساختار پوشه‌ی `src`

پوشه‌ی اصلی `src` شامل چهار زیرپوشه‌ی مهم به همراه فایل اصلی App.tsx است:

### `components/`

شامل تمام کامپوننت‌های نمایشی و تعاملی مانند Canvas، Sidebar، Header و ShapeCounter است. هر فایل مسئول یک بخش از رابط کاربری است.

### `context/`

این پوشه شامل یک context به نام `ShapesContext` است که وظیفه‌ی مدیریت متمرکز لیست اشکال و فراهم‌کردن امکان دسترسی global به آن را برعهده دارد.

### `types/`

تمام انواع داده‌ای TypeScript مورد نیاز پروژه مانند نوع Shape و نوع ShapeType در این پوشه تعریف شده‌اند. این ساختار کمک می‌کند پروژه از نظر نوع‌دهی دقیق، ایمن و قابل گسترش باشد.

### `styles/`

در این پوشه فایل‌های CSS Module مربوط به هر کامپوننت قرار دارند. استفاده از CSS Module باعث می‌شود که استایل‌ها scoped باشند و از تداخل بین کلاس‌ها جلوگیری شود.

---

## توضیح کامل فایل‌ها و منطق پیاده‌سازی ویژگی‌ها

### App.tsx

در App.tsx، علاوه بر اتصال کامپوننت‌ها و تعریف ساختار اصلی رابط کاربری، داده‌هایی مانند `selectedShape` به عنوان prop به کامپوننت‌های فرزند ارسال می‌شوند. این روش به جای context برای این داده استفاده شده تا App به عنوان container بالادستی، فقط مسئول هماهنگی باشد و فرزندان وابستگی مستقیم به هم نداشته باشند.

`selectedShape` به Sidebar داده می‌شود تا مشخص کند کدام شکل انتخاب شده و آیکون آن برجسته شود، و به Canvas ارسال می‌شود تا اگر کاربر کلیک کرد یا یک شکل را drag و drop کرد، شکل انتخاب‌شده روی بوم ایجاد شود.

نقطه‌ی اصلی راه‌اندازی رابط کاربری پروژه است. در این فایل، حالت انتخاب‌شده‌ی شکل در `selectedShape` نگهداری می‌شود، سپس کامپوننت‌های `Header`، `Canvas`، `Sidebar` و `ShapeCounter` در کنار هم قرار گرفته‌اند. داده‌های مربوط به اشکال از طریق context `ShapesProvider` به صورت global در اختیار همه‌ی این اجزا قرار گرفته است. اتصال props بین Sidebar و Canvas، امکان تعامل بین انتخاب شکل و ترسیم آن را فراهم کرده و ساختار ظاهری صفحه به گونه‌ای طراحی شده که نوار کناری در سمت راست، بوم نقاشی در مرکز و نوار عنوان در بالا قرار گیرد.

---

## پوشه‌ی components

### Header.tsx

در Header، عملیات مربوط به ویرایش عنوان و مدیریت import/export فایل‌های JSON انجام می‌شود. کاربر می‌تواند با کلیک روی دکمه‌های مشخص‌شده، داده‌ها را ذخیره یا بارگذاری کند.

برای **عملیات export**، ابتدا آرایه‌ی اشکال از context گرفته می‌شود. سپس با استفاده از `JSON.stringify`، این آرایه به یک رشته‌ی JSON تبدیل می‌شود. برای ایجاد فایل دانلود، از `Blob` و `URL.createObjectURL` استفاده شده و فایل نهایی با نامی مشتق‌شده از عنوان صفحه (که در فیلد عنوان تایپ شده) ساخته می‌شود. این نام در فایل خروجی لحاظ می‌شود تا export معنادارتر و قابل‌شناسایی‌تری باشد.

برای **عملیات import**، کاربر از یک ورودی `file input` برای انتخاب فایل JSON استفاده می‌کند. سپس با استفاده از `FileReader`، محتوای فایل خوانده می‌شود. پس از بررسی صحت ساختار فایل (یعنی آرایه‌ای از اشیاء دارای `id`، `type`، `x` و `y`)، این داده‌ها از طریق `setShapes` در context جایگزین لیست موجود می‌شوند. اگر ساختار نامعتبر باشد یا JSON parsing شکست بخورد، هشدار مناسبی به کاربر نمایش داده می‌شود.


در Header، عملیات مربوط به ویرایش عنوان و مدیریت import/export فایل‌های JSON انجام می‌شود. برای تغییر عنوان، یک فیلد `input` در نظر گرفته شده که مقدار آن در state محلی ذخیره شده و همزمان با تایپ کاربر به‌روزرسانی می‌شود. در قسمت export، از تابع `JSON.stringify` برای تبدیل اشکال ذخیره‌شده در context به یک رشته JSON استفاده می‌شود، سپس از `Blob` و `URL.createObjectURL` برای تولید فایل و ایجاد لینک دانلود بهره گرفته می‌شود. نام فایل از عنوان داده‌شده گرفته می‌شود.

در فرآیند import نیز از `input` نوع `file` و `FileReader` استفاده شده تا محتوای فایل خوانده‌شده و در صورت معتبر بودن، با آرایه‌ی اشکال در context جایگزین شود. اگر ساختار فایل نادرست باشد، پیام هشدار به کاربر نمایش داده می‌شود.

### Sidebar.tsx

این کامپوننت لیست اشکال قابل انتخاب و Drag را نمایش می‌دهد. کاربر می‌تواند با کلیک روی آیکون هر شکل، آن را انتخاب کند. در این صورت مقدار `selectedShape` در App تنظیم می‌شود. همچنین، در زمان drag کردن، مقدار نوع شکل با استفاده از `event.dataTransfer.setData` ذخیره می‌شود تا در لحظه drop روی canvas قابل استخراج باشد. ظاهر آیکون انتخاب‌شده با کلاس CSS ویژه مشخص شده و رنگ آیکون‌ها با رنگ واقعی اشکال روی canvas همخوانی دارد.

### Canvas.tsx

این کامپوننت مسئول ترسیم اشکال، جابجایی داخلی آن‌ها و حذف اشکال است. اگر شکلی انتخاب شده باشد، با کلیک روی canvas یک شکل جدید با مختصات مکان ماوس ایجاد می‌شود. برای این منظور، از رویداد `onClick` استفاده شده و موقعیت کلیک از `event.nativeEvent.offsetX` و `offsetY` استخراج می‌شود.

اگر کاربر یک شکل را از sidebar drag کند و روی canvas رها نماید، نوع شکل از `dataTransfer` بازیابی شده و در مختصات drop اضافه می‌شود. این کار از طریق رویدادهای `onDragOver` برای جلوگیری از رفتار پیش‌فرض مرورگر و `onDrop` برای استخراج اطلاعات و ایجاد شکل انجام می‌گیرد.

برای drag داخلی، در هنگام کلیک (`onMouseDown`) روی یک شکل، شناسه‌ی آن در state ذخیره می‌شود. سپس در رویداد `onMouseMove`، اگر ماوس نگه‌داشته شده باشد (`draggedShapeId` وجود داشته باشد)، مختصات شکل در context به‌روزرسانی می‌گردد. در پایان، هنگام رها کردن ماوس (`onMouseUp`) حالت drag غیرفعال می‌شود.

در صورت دوبار کلیک (`onDoubleClick`) روی یک شکل، با بررسی مختصات ماوس و بررسی فاصله از هر شکل موجود، نزدیک‌ترین شکل (اگر داخل محدوده باشد) از context حذف می‌شود. روی یک شکل، با بررسی مختصات، آن شکل از context حذف می‌شود.

### ShapeCounter.tsx

کامپوننت ShapeCounter مسئول نمایش تعداد اشکال رسم‌شده از هر نوع (دایره، مربع، مثلث) است. این کامپوننت با استفاده از context، لیست اشکال را دریافت می‌کند و با استفاده از فیلتر، تعداد هر نوع شکل را محاسبه می‌کند. به‌جای ذخیره‌ی تعداد اشکال در context، از ویژگی زنده‌ی React بهره می‌گیرد تا شمارنده‌ها را همزمان با هر تغییری در لیست اشکال به‌روز کند.

در پشت صحنه، این کامپوننت از توابعی مانند زیر استفاده می‌کند:

```ts
const circleCount = shapes.filter(s => s.type === 'circle').length;
```

هر بار که لیست `shapes` در context تغییر می‌کند (افزودن، حذف یا جابجایی اشکال)، شمارنده‌ها نیز به‌طور خودکار به‌روزرسانی می‌شوند. رنگ هر شمارنده دقیقاً با رنگ اشکال متناظر روی canvas مطابقت دارد. این هماهنگی به درک بصری بهتر توسط کاربر کمک می‌کند.

در JSX این کامپوننت، برای هر نوع شکل یک بخش جداگانه تعریف شده که در آن شمارنده مربوطه و رنگ آن نمایش داده می‌شود. این ساختار به صورت خودکار با تغییر context واکنش نشان می‌دهد و بنابراین نیاز به نگهداری شمارش در context وجود ندارد.

این کامپوننت تعداد اشکال موجود از هر نوع را نمایش می‌دهد. لیست اشکال از context دریافت می‌شود و با استفاده از فیلتر، تعداد `circle`، `square` و `triangle` شمرده می‌شود. رنگ شمارنده‌ها با رنگ شکل‌های مربوطه همخوانی دارد و در پایین صفحه به صورت یک نوار نمایش داده می‌شود.

---

## پوشه‌ی context

### ShapesContext.tsx

این فایل شامل context برای نگهداری لیست اشکال است. از `createContext` و `useState` برای مدیریت وضعیت استفاده می‌شود. توابع `setShapes`، `addShape`، `updateShape` و `deleteShape` در اختیار سایر اجزا قرار می‌گیرند.

از این context برای نگهداری **تنها آرایه‌ای از اشکال (`Shape[]`)** استفاده شده است. اطلاعات مربوط به مختصات، نوع و شناسه هر شکل در این آرایه ذخیره می‌شود. شمارش اشکال در context نگهداری نمی‌شود، بلکه کامپوننت‌ها مانند `ShapeCounter` با استفاده از `filter()` روی این آرایه، شمارش‌های زنده را انجام می‌دهند.

از hook سفارشی `useShapes()` برای دسترسی راحت‌تر به context استفاده می‌شود و تمام اجزای پروژه می‌توانند با استفاده از این hook اشکال را اضافه، ویرایش یا حذف کنند. برای نگهداری لیست اشکال است. از `createContext` و `useState` برای مدیریت وضعیت استفاده می‌شود. توابع `setShapes`، `addShape`، `updateShape` و `deleteShape` در اختیار سایر اجزا قرار می‌گیرند. از hook سفارشی `useShapes()` برای دسترسی راحت‌تر به context استفاده می‌شود و تمام اجزای پروژه می‌توانند با استفاده از این hook اشکال را اضافه، ویرایش یا حذف کنند.

---

## پوشه‌ی types

### shapes.ts

در این فایل، انواع داده‌ای مورد نیاز برای شکل‌ها تعریف شده‌اند. نوع `ShapeType` فقط یکی از مقادیر 'circle'، 'square' یا 'triangle' را می‌پذیرد. نوع `Shape` شامل شناسه یکتا، نوع شکل و مختصات مکان آن است. این ساختار در تمام پروژه استفاده می‌شود تا اطمینان حاصل شود که اشکال دارای ساختار صحیح هستند.

---

## پوشه‌ی styles

هر فایل CSS Module در این پوشه مختص یک کامپوننت خاص است. این روش باعث می‌شود که استایل‌ها فقط در همان کامپوننت اعمال شوند و از تداخل جلوگیری شود. رنگ‌ها، مرزها، ابعاد و حالت‌های انتخاب‌شده‌ی اشکال به کمک این فایل‌ها کنترل می‌شوند. همچنین چینش اجزا مانند sidebar و canvas با استفاده از کلاس‌های این بخش تنظیم می‌شود.

---

## اطلاعات منتقل‌شده با props و دلایل آن

اطلاعاتی که به صورت props بین کامپوننت‌ها رد و بدل شده‌اند، به گونه‌ای طراحی شده‌اند تا ارتباط ساده‌ و واضحی بین پدر (App.tsx) و فرزندان برقرار باشد. مهم‌ترین prop در این پروژه، `selectedShape` است که از App.tsx به دو کامپوننت فرزند یعنی Sidebar و Canvas منتقل می‌شود.

در App.tsx، state مربوط به `selectedShape` نگهداری می‌شود تا مشخص کند کاربر چه نوع شکلی را برای رسم انتخاب کرده است. این مقدار به Sidebar منتقل می‌شود تا بتواند شکل انتخاب‌شده را به صورت بصری (با outline یا برجسته‌سازی) نمایش دهد و کاربر بداند کدام شکل فعال است.

همین مقدار به Canvas نیز داده می‌شود تا اگر کاربر روی canvas کلیک کرد یا شکلی را از sidebar کشید و روی canvas رها کرد، بدانیم چه نوع شکلی باید ایجاد شود.

استفاده از props در اینجا باعث شده که این دو کامپوننت مستقل از یکدیگر باقی بمانند و App.tsx به عنوان container بتواند تعامل بین آن‌ها را مدیریت کند بدون نیاز به context جدید یا coupling شدید بین آن‌ها.

در این پروژه، بین برخی کامپوننت‌ها اطلاعاتی از طریق `props` منتقل شده است تا امکان تعامل بین اجزای مستقل فراهم شود. برای مثال، در `App.tsx` وضعیت `selectedShape` نگهداری می‌شود، و این مقدار به صورت `prop` به `Sidebar` و `Canvas` ارسال می‌شود. هدف از این کار جلوگیری از ایجاد context اضافی و حفظ مسئولیت‌پذیری هر کامپوننت است.

در `Sidebar`، این prop برای مشخص کردن شکل انتخاب‌شده و نمایش آن به کاربر استفاده می‌شود. در `Canvas`، همین prop برای تشخیص این موضوع به کار می‌رود که در صورت کلیک یا drop، چه شکلی باید ایجاد شود. این تبادل اطلاعات ساده بین parent و child باعث می‌شود که کنترل بالا روی منطق رسم حفظ شود، بدون آن‌که کامپوننت‌ها به یکدیگر tightly coupled شوند.

---



## سخن نهایی 

بخش‌هایی از استایل‌دهی پروژه (CSS Modules) و همچنین انتخاب و مدیریت رویدادهای مختلف مانند کلیک، حرکت ماوس، دوبار کلیک، drag و drop با کمک مدل زبان GPT طراحی و تکمیل شده‌اند. این کمک شامل تحلیل رفتار مناسب کامپوننت‌ها در هنگام تعامل کاربر، شناسایی صحیح رویدادهای مورد نیاز و نحوه‌ی استفاده‌ی درست از آن‌ها در React و TypeScript بوده است.


